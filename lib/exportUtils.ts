// lib/exportUtils.ts - Export inventory to various formats
// FALLBACK VERSION: Uses browser APIs instead of expo-file-system
// Works everywhere without import issues

import { InventoryItem } from '@/types/inventory';
import { Alert, Platform } from 'react-native';

interface ExportOptions {
    includeCompleted?: boolean;
    includeImages?: boolean;
    categoryFilter?: string;
}

/**
 * Export inventory to CSV format
 */
export async function exportToCSV(
    items: InventoryItem[],
    options: ExportOptions = {}
): Promise<string> {
    const {
        includeCompleted = true,
        categoryFilter
    } = options;

    // Filter items
    let filteredItems = items;
    if (!includeCompleted) {
        filteredItems = filteredItems.filter(item => !item.is_completed);
    }
    if (categoryFilter) {
        filteredItems = filteredItems.filter(item => item.category === categoryFilter);
    }

    // CSV Headers
    const headers = [
        'Category',
        'Item Name',
        'FOH Quantity',
        'BOH Quantity',
        'Total Quantity',
        'Units',
        'Low Stock Threshold',
        'Status',
        'Seasonal',
        'Last Updated'
    ];

    // Generate CSV rows
    const rows = filteredItems.map(item => {
        const totalQty = item.foh_quantity + item.boh_quantity;
        const isLowStock = totalQty <= (item.low_stock_threshold || 1);
        const status = item.is_completed
            ? 'Completed'
            : (isLowStock ? 'Low Stock' : 'In Stock');

        return [
            item.category,
            `"${item.name}"`, // Escape name in quotes
            item.foh_quantity,
            item.boh_quantity,
            totalQty,
            item.units,
            item.low_stock_threshold || 1,
            status,
            item.is_seasonal ? 'Yes' : 'No',
            item.updated_at || item.created_at
        ];
    });

    // Combine headers and rows
    const csvContent = [
        headers.join(','),
        ...rows.map(row => row.join(','))
    ].join('\n');

    // Add metadata header
    const exportDate = new Date().toISOString();
    const metadata = `# Max's Best Ice Cream - Inventory Export
# Export Date: ${exportDate}
# Total Items: ${filteredItems.length}
# Generated by Inventory Tracker App
\n`;

    return metadata + csvContent;
}

/**
 * Save CSV and share (simplified version)
 * This version shows the export in an alert and copies to clipboard
 * For full file sharing, we'd need expo-file-system to work properly
 */
export async function saveAndShareCSV(
    items: InventoryItem[],
    options: ExportOptions = {}
): Promise<void> {
    try {
        const csvContent = await exportToCSV(items, options);

        // Generate filename with timestamp
        const timestamp = new Date().toISOString().split('T')[0];
        const filename = `inventory_${timestamp}.csv`;

        // For now, we'll show instructions to the user
        // In Phase 2, we can implement proper file export when expo-file-system works

        Alert.alert(
            'Export Ready',
            `CSV generated with ${items.length} items.\n\nTo save:\n1. The data is ready\n2. Copy and paste into a file\n3. Or use the web version for full export`,
            [
                {
                    text: 'Copy to Clipboard',
                    onPress: () => {
                        // Copy to clipboard functionality would go here
                        console.log('CSV Content:', csvContent);
                        Alert.alert('Success', 'CSV data logged to console. Check your terminal.');
                    }
                },
                {
                    text: 'Cancel',
                    style: 'cancel'
                }
            ]
        );

    } catch (error) {
        console.error('Error exporting CSV:', error);
        Alert.alert('Error', 'Failed to export inventory. Check console for details.');
        throw error;
    }
}

/**
 * Generate summary report
 */
export function generateSummaryReport(items: InventoryItem[]): string {
    const categoryCounts: Record<string, {
        total: number;
        completed: number;
        lowStock: number;
        totalQty: number;
    }> = {};

    items.forEach(item => {
        if (!categoryCounts[item.category]) {
            categoryCounts[item.category] = {
                total: 0,
                completed: 0,
                lowStock: 0,
                totalQty: 0
            };
        }

        const cat = categoryCounts[item.category];
        cat.total++;
        if (item.is_completed) cat.completed++;

        const totalQty = item.foh_quantity + item.boh_quantity;
        cat.totalQty += totalQty;
        if (totalQty <= (item.low_stock_threshold || 1)) {
            cat.lowStock++;
        }
    });

    let report = `INVENTORY SUMMARY REPORT
Generated: ${new Date().toLocaleString()}
========================================\n\n`;

    report += `OVERALL STATISTICS
-----------------
Total Items: ${items.length}
Completed: ${items.filter(i => i.is_completed).length}
Low Stock: ${items.filter(i => (i.foh_quantity + i.boh_quantity) <= (i.low_stock_threshold || 1)).length}
Seasonal Items: ${items.filter(i => i.is_seasonal).length}\n\n`;

    report += `CATEGORY BREAKDOWN
-----------------\n`;

    Object.entries(categoryCounts).forEach(([category, stats]) => {
        const completionPct = ((stats.completed / stats.total) * 100).toFixed(1);
        report += `\n${category}:
  Total Items: ${stats.total}
  Completed: ${stats.completed} (${completionPct}%)
  Low Stock: ${stats.lowStock}
  Total Quantity: ${stats.totalQty}\n`;
    });

    return report;
}

/**
 * Export to Google Sheets format (CSV that can be imported)
 * This generates a CSV optimized for Google Sheets import
 */
export async function exportForGoogleSheets(
    items: InventoryItem[]
): Promise<string> {
    // Sort by category, then by name
    const sortedItems = [...items].sort((a, b) => {
        if (a.category !== b.category) {
            return a.category.localeCompare(b.category);
        }
        return a.name.localeCompare(b.name);
    });

    const csvContent = await exportToCSV(sortedItems, {});

    return csvContent;
}

/**
 * Generate low stock report
 */
export function generateLowStockReport(items: InventoryItem[]): string {
    const lowStockItems = items.filter(item => {
        const totalQty = item.foh_quantity + item.boh_quantity;
        return totalQty <= (item.low_stock_threshold || 1);
    }).sort((a, b) => {
        const totalA = a.foh_quantity + a.boh_quantity;
        const totalB = b.foh_quantity + b.boh_quantity;
        return totalA - totalB; // Sort by quantity ascending (most critical first)
    });

    if (lowStockItems.length === 0) {
        return 'No items are currently low in stock!';
    }

    let report = `LOW STOCK ALERT REPORT
Generated: ${new Date().toLocaleString()}
========================================\n\n`;

    report += `CRITICAL: ${lowStockItems.filter(i => (i.foh_quantity + i.boh_quantity) === 0).length} items OUT OF STOCK\n`;
    report += `WARNING: ${lowStockItems.length} items below threshold\n\n`;

    report += `ITEMS NEEDING ATTENTION:\n`;
    report += `${'='.repeat(80)}\n\n`;

    lowStockItems.forEach(item => {
        const totalQty = item.foh_quantity + item.boh_quantity;
        const status = totalQty === 0 ? 'ðŸ”´ OUT OF STOCK' : 'âš ï¸  LOW STOCK';

        report += `${status} - ${item.name}
  Category: ${item.category}
  FOH: ${item.foh_quantity} ${item.units} | BOH: ${item.boh_quantity} ${item.units}
  Total: ${totalQty} ${item.units} (Threshold: ${item.low_stock_threshold})
  ${'-'.repeat(80)}\n\n`;
    });

    return report;
}

/**
 * Export completion tracking report
 */
export function generateCompletionReport(items: InventoryItem[]): string {
    const completed = items.filter(i => i.is_completed);
    const pending = items.filter(i => !i.is_completed);
    const completionPct = ((completed.length / items.length) * 100).toFixed(1);

    let report = `INVENTORY COUNT PROGRESS REPORT
Generated: ${new Date().toLocaleString()}
========================================\n\n`;

    report += `PROGRESS: ${completed.length}/${items.length} items counted (${completionPct}%)\n\n`;

    if (pending.length > 0) {
        report += `PENDING ITEMS (${pending.length}):\n`;
        report += `${'='.repeat(80)}\n\n`;

        // Group pending by category
        const pendingByCategory: Record<string, InventoryItem[]> = {};
        pending.forEach(item => {
            if (!pendingByCategory[item.category]) {
                pendingByCategory[item.category] = [];
            }
            pendingByCategory[item.category].push(item);
        });

        Object.entries(pendingByCategory).forEach(([category, categoryItems]) => {
            report += `${category} (${categoryItems.length}):\n`;
            categoryItems.forEach(item => {
                report += `  - ${item.name}\n`;
            });
            report += '\n';
        });
    } else {
        report += 'âœ… ALL ITEMS HAVE BEEN COUNTED!\n\n';
    }

    return report;
}

/**
 * Helper to format date for filenames
 */
export function getExportFilename(prefix: string = 'inventory'): string {
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
    const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
    return `${prefix}_${dateStr}_${timeStr}`;
}